(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{516:function(t,_,a){"use strict";a.r(_);var l=a(6),v=Object(l.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"内容概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内容概述"}},[t._v("#")]),t._v(" 内容概述")]),t._v(" "),a("h2",{attrs:{id:"一、浮动float"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、浮动float"}},[t._v("#")]),t._v(" 一、浮动float")]),t._v(" "),a("p",[t._v("在css中，由3中常见的方法对元素进行定位、布局")]),t._v(" "),a("ul",[a("li",[t._v("normal flow：标准流、常规流、文档流")]),t._v(" "),a("li",[t._v("absolute positioning：绝对定位")]),t._v(" "),a("li",[t._v("float：浮动")])]),t._v(" "),a("h3",{attrs:{id:"_1-1float"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1float"}},[t._v("#")]),t._v(" 1.1float")]),t._v(" "),a("ul",[a("li",[t._v("none 不浮动，默认值")]),t._v(" "),a("li",[t._v("left 向左浮动")]),t._v(" "),a("li",[t._v("right 向右浮动")])]),t._v(" "),a("h3",{attrs:{id:"_1-2浮动的规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2浮动的规则"}},[t._v("#")]),t._v(" 1.2浮动的规则")]),t._v(" "),a("ul",[a("li",[t._v("元素一旦浮动，脱离标准流，向左或右移动，知道自己的边界紧贴着包含块（一般是父元素）或者其他浮动元素的边界")]),t._v(" "),a("li",[t._v("浮动元素不能与行内级内容层叠，行内级内容将会被浮动元素推出")]),t._v(" "),a("li",[t._v("行内及元素、inline-block元素浮动后，其顶部将所在行的顶部对齐")]),t._v(" "),a("li",[t._v("如果元素是向左（右）浮动，浮动元素的左（右）边界不能超过包含块的左（右）边界")]),t._v(" "),a("li",[t._v("浮动元素不能层叠\n"),a("ul",[a("li",[t._v("如果一个元素浮动，另一个浮动元素已经在那个位置，后浮动的元素将紧贴着前一个浮动元素（左浮动找左浮动")]),t._v(" "),a("li",[t._v("如果水平方向剩余空间不够显示浮动元素，浮动元素将向下移动，直到由充足空间为止")])])]),t._v(" "),a("li",[t._v("浮动元素的顶端不能超过包含块的元素，也不能超过之前所有浮动元素的顶端")])]),t._v(" "),a("p",[t._v("问题：在进行布局时，同一行多个元素摆放后，设置margin-right让他们直接产生间距，那么最后一个元素设置的margin-right总是多余")]),t._v(" "),a("ul",[a("li",[t._v("解决一：每一行的最后一个元素，总是加一个class，通过类选择器去除margin-right")]),t._v(" "),a("li",[t._v("解决二：通过伪类选择器")]),t._v(" "),a("li",[t._v("解决三：.container固定的宽度>.warp + -marging>很多的item")])])])}),[],!1,null,null,null);_.default=v.exports}}]);