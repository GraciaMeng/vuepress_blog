# 1.防抖

## （1）概念描述

- ### 什么是防抖？

  - 在一个任务被频繁触发的情况下，只有当任务触发的间隔超过指定间隔的时候，该任务才会执行

- ### 考察点？

  - 闭包的使用

- ### 解决什么问题？

  - 在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如resize、scroll、mousemove。。。，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。
  - 一般来说，防抖是比较好的解决方案。

- ### 场景复现？

  - 网站头部的输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。

## （2）代码实现

```js
function debounce(delay,callback){
    let timer;
    return function(value){
        clearTimeout(timer);
        timer = setTimeout(()=>{
            callback && callback(value);
        },delay)
    }
}
function logValue(value){
    console.log(value)
}
let input = document.getElementId('debounce');
let debounceInput = debounce(1000,logValue);
input.addEventListener('keyup',function(e){
    debounceInput(e.target.value);
})
```

# 2.节流

## （1）概念描述

- ### 什么是节流？

  - 规定再一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。

- ### 考察点？

  - 闭包的使用

- ### 解决什么问题？

  - 用户点击提交按钮，假设在我们知道接口大致的返回时间的情况下，我们使用节流，只允许一定时间内点击一次。
  - 懒加载要监听计算滚动的位置，使用节流按一定时间的频类获取

## （2）代码实现

```js
function throttle(delay,callback){
    let timer = null;
    return function(){
        if(!timer){
            timer = setTimeout(()=>{
                callback && callback();
                timer = null;
            },delay)
        }
    }
}
function logValue(){
    console.log(a)
}
let input = document.getElementById('throttle');
let throttleInput = throttle(1000,logValue);
input.addEventListener('keyup',function(e){
    throttleInput(e.target.value);
})
```

## （3）总结

- 函数防抖和函数节流都是防止某一时间频繁触发，但两者的原理却不一样
- 函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行。
